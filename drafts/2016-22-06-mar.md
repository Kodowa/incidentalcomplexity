In February we [released WikiEve]() to friends and family, hoping to get some good feedback on our new direction. Our ideas about the UI had evolved significantly since the release of V0, so we were excited to hear what people had to say.

### UI

The bulk of the feedback related to the NL interface and the card concept. 

#### Formulas

In March, we spent a lot of time looking at ways to imporove the NL interface, due to feedback we received on WikiEve. We started by considering a controlled natrual language interface, which would drastically simplify the NL problem while still being readable. However, we soon arrived at something that felt more akin to Excel formulas.

![Formula](images/formula1.png)

A user of the NL interface might have asked this as "What is the average number of moons per planet?". The formula version is a little awkward to read, but an English reader without any coding experience could figure out what this sentence means.

One issue with this introduces a scoping problem. The NL interface was designed to figure out the extent of functions like average and count. Is this `average(count(moons)) per plant` or `average(count(moons per planet))`? This version makes that explicit

![Formula](images/formula2.png)

Another thing the NL interface did was find relations between words that were not directly related. In a previous post we looked at the example `sum salary per department`. Here, `salary` and `department` are only related through the eployees. This version makes that explicit

![Formula](images/formula3.png)

Even a version closer to Excel is still not that bad. Excel has proven that people are capable of writing formulas like this, so with the right tools and guidance, they should be able to write something like this.

![Formula](images/formula4.png)

We even started experimenting with how a user might write multi-step queries. In Excel, you would reference the result of another cell, using a cell address like `A3`. Here, you can reference different steps of a calculation. This helps guide the user to break down complicated queries into smaller steps. If you read the queries from top to bottom, it's pretty clear what's going on here. The grammar is not true English, but it's close enough to feel familiar.

![Formula](images/formula5.png)

In the end, we didn't implement any of these formula concepts in a working system. After about a week of riffing on this concept, we arrived at a different take that was much more promising. 


#### GridEve + WikiEve = WikiGrid

In developing Eve, we often tend to circle around ideas. This is the case again, as we decided to revisit GridEve. One key property we want Eve to have is the ability to be instantly useful. Even if you have no idea how to use Excel, you can at least type things into cells and use the grid to organize ideas. I've started many useful spreadsheets this way. 
 Most versions of Eve so far have required some upfront work before the system became a useful tool e.g. requiring the user to import data or define a schema.

GridEve was one of the first versions that had this property, so we wanted to explore that more. Also, our work on the formula language lead us to an intersting way to formulate queries using a grid. Let's take a look at GridEve 2.0: WikiGrid.

#### Interface

The UI is a combination of GridEve and WikiEve. The user is initially presented with a grid of cells. Each cell is square and fixed, in contrast to Excel, where they can be resized. Cells in WikiGrid can contain anything, such as text, tables, formulas, or even cards from WikiEve

![WikiGrid](images/wikigrid1.png)

Even though the grid is fixed, you can select multple cells and turn them into a "macro cell", which offers some interesting interactions. Here, a user is navigating using a keyboard.

![WikiGrid](images/wikigrid1.gif)

And here, a user is selecting various cells. When occupied cells (the large white ones) fall in the selection window, only those are selected. When only empty cells are in the selection window, they are selected.

![WikiGrid](images/wikigrid2.gif)

Finally, we see how sub-grids can be embedded in a cell. It's grids all the way down. The ghosting cursor was an experiment to see if hiding gridlines made it look cleaner.

![WikiGrid](images/wikigrid3.gif)

### Platform

For the platform, our main goal for March was to get a server running and everyone in the office connected to it and coding via a repl. Over the course of a couple months we transitioned from a traditional key-store relational model to storing `(Entity, Attribute, Value)` triples we call EAVs. This month, we expanded this triple to include additional parameters: Bag, Tick, and User. So the full specification for a fact is now `(Entity, Attribute, Value, Bag, Tick, User)`.

- *Bag* - A partitioning of facts. This is the closest analogy to a file that Eve offers. You might put all your facts about planets and astronomers into one bag, while your quarterly earnings report goes into a different bag. Bags will help us with features like version control and distribution. For example, the logic for a networked game like Chess might be one held in bag A. A specific instance of that game for two players would be created from that bag. Then each player would have their own personal bags representing their local state, which is coordinated through the instance bag. Like so:
- *Tick* - The time when the fact was created. This allows a partial ordering of the facts. I will have a lot more to say about this in a future post, but this enables some exciting features like travel debbuging, and what-if scenarios. 
- *User* - The ID of the user who created the fact. This would allow you to query or exclude all facts added to Eve by a particular user, for instance. Or it can be used to figure out who added a particular fact to the database. This will help for things like permissions. If Steve from accounting is notorious for  

#### Server

Cardwiki used an old runtime written in TypeScript (dating back to CardWiki) that relied on the client's `localStorage` to hold the database, which is limited to 5MB. Not needed a server like the GraphEve was nice, but we could not easily support feartures like distribution, redundancy, or collaboration this way. Since Eric started in December, he had been working on a new runtime, (ClojEve, written in Clojure), as the rest of us worked on WikiEve. By April we were ready to migrate to this new environment, which means we needed a protocol. We landed on a JSON interface with three thingies: query, error, result, and close.

```
query: 
{
    type: "query"
    id: id
    query: query
}

close 
{
    type: "close"
    id: id
}
```

The client can send two types of messages: a `query` or a `close`. Each query has a UUID. This is sent to the server along with a plain text query written in our query syntax (more on that in the next section). Any query sent to the server remnains open indefiniately, until the client sends a `close` message with the corresponding ID.

```
result: 
{
    type: "result"
    id: id
    adds: adds
    removes: removes
}

error:
{
    type: "error"
    id: id
    reason: reasons 
}
```

When the server first receives a query, it sends back a result message. This message is contains the ID of the associated query, along with any additions or removals from the results. The initial result will only have adds, since it is computed from scratch. But if the query remains open, adds and removes are sent incrementally as the database mutates. 

#### Syntax and Compiler

Last month, we re-introduced a syntax for Eve for the first time since 2014. The syntax was an s-expression style syntax, intended for internal use only. In general, we were happy with this because it allowed us to easily translate tree-like structures to the sytnax. For instance, this made building the NL interface easier. This month, we made some changes to the syntax to make it easier to write. We removed the `project!` statement, replacing it with a bracket syntax. Further, we removed the `select` statement, and replaced it with `fact`, which can act like multiple `selects` at once. For example, this

```
(query
 (select "eavs" :entity "apple" :attribute "color" :value color)
 (select "eavs" :entity "apple" :attribute "tag" :value tag)
 (project! :color color :tag tag))
```

becomes

```
(query [color tag]
  (fact "apple" :color :tag))
```

Which is much simpler. This works using a two-stage compilation process. We first parse the original input and translate that to an intermediate representation called SMIL, which decomposes the query into a more primitive form. The above query compiles to the following SMIL:

```
(query [color tag] 
  (fact-btu :entity "apple" :attribute "color" :value color) 
  (fact-btu :entity "apple" :attribute "tag" :value tag))
```

Here, the `fact` statement has decomposed into two `fact-btu` statements, which resemble the `select` statement of the previous syntax. SMIL code then goes through another level of translation, which turns it into WEASL, a sort of assembly-level language for Eve. The above SMIL translates into the following WEASL:

```
((bind
  main 
   ((tuple [3] [0] [1] * nil) (send "query2725||color,tag" [3]))) 
 (bind 
   "query2725||color,tag" 
   ((scan [3] []) 
    (delta-e [4] [3]) 
    (= [3] [4 0] "apple") 
    (filter [3]) (= [3] [4 1] "color") 
    (filter [3]) (scan [3] []) 
    (delta-e [5] [3]) 
    (= [3] [5 0] "apple") 
    (filter [3]) 
    (= [3] [5 1] "tag") 
    (filter [3]) 
    (tuple [3] [0] [1] [2 2] nil [4 2] [5 2]) 
    (send "query2725||color,tag-cont" [3]))) 
 (bind 
   "query2725||color,tag-cont" 
   ((delta-c [4] [5]) 
    (tuple [3] [0] [1] [4] [5]) 
    (send out [3]))))
```
Finally, the above code is sent to the executor, which executes the code and returns a result. In the context of the client-server architecture, the result is packaged as an incremental add/remove message, which is sent to all clients listening to that query. If the executor encounters and error while running the query, an error message is packaged in the error, indicating what the error was, and where in the source the error occurred.

The SMIL and WEASL translations for each query are passed to the sender in an "info" message. This message contains metadata meant to enable interesting interactions for editors. For example, in the future we can add the whole parse tree to this message, and then a client editor can use that to style text code. 

### REPL ([github](https://github.com/witheve/Eve/tree/90a6c6bc4597572a29c72119fc7bb964426f8107))

Putting it all together, we started building a REPL. A basic REPL for Eve is actually very simple, given the protocol laid out above. When you start the REPL, it opens a websocket connection to an Eve server. Then you can type a query in a textbox and send it to the server. The REPL forms a message according to the query protocol and waits for a response from the server. When a response is received, the REPL displays it according to its type. Result messages are rendered as a table, while error messages are rendered as text.

![REPL](images/repl1.png)

In this example REPL session, the user adds some new facts about apples in the first card. In the second card, the user asks for all EAV facts in the system, which are displayed in a table. The final query is malformed, so Eve returns an error message.

But since this isn't an ordinary REPL for an ordinary language, we have some nice behaviors. Queries are left open by default, so they continuously receive updates from the server as they become available. So if another Eve user adds a fact that affacts any of your open queries, you'll see that change immediately. 

![REPL](images/repl2.png)

Here, the user added new facts about lemons, which are added to the result table in the second query.

Other features include the ability to save/load REPL workspaces to/from a file, automatic reconnect if the server dies, and the ability to export result tables as CSV files. And of course, dark mode!

![REPL](images/repl3.png)